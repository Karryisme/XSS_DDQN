# XSS_DDQN

## DQNAgent 的核心作用

- **Dueling DQN 神經網路**：讓模型同時考慮「這個狀態本身好不好」與「這個動作好不好」，讓學習更穩定。
- **Double DQN 技術**：避免模型過度自信（overestimate）某些動作。
- **Prioritized Experience Replay**：學會更重視重要的學習經驗，加快訓練速度。
- **ε-greedy 策略**：有時候隨機亂試、有時候選最好的動作，以平衡探索與利用。

---

## DuelingDQN 的核心作用

- **Dueling 機制合併公式**：
  - 輸出 Q 值時，不是單純用 V 或 A，而是組合成：
    ```
    Q(s, a) = V(s) + (A(s, a) - 平均A(s, a))
    ```
    這樣可以避免「動作價值太接近」時讓網路無法分辨。
- **更穩定的學習效果**：
  - Dueling 架構能讓模型在不依賴特定動作的情況下，也能學到狀態好壞，減少過度擬合某些動作帶來的偏誤。

---

## ActionTable 的核心作用

用於生成新的攻擊向量並繞過防禦機制：

- XSS 攻擊向量生成的核心是透過變異（mutate）樣本來獲得能夠觸發目標程式異常狀態的新樣本。
- 由於網頁應用程式通常會設置過濾、編碼等防禦措施來防禦 XSS 攻擊，因此需要透過各種編碼來繞過這些防禦機制的檢測。

---

## MyHTMLParse 的核心作用

- **自訂 Node 類別**：定義 DOM 樹的基本節點結構，包括節點類型（document、element、text）、標籤名稱、屬性、文字內容、子節點與父節點資訊。
- **繼承 Python 內建 HTMLParser 類別**：自訂 MyHTMLParser 類別，解析 HTML 並建構一棵樹狀結構，模擬瀏覽器解析 HTML 的過程。
- **處理起始標籤 `handle_starttag()`**：遇到 `<tag>` 時，建立一個新的 element 節點，掛到當前節點的 children 上，並把目前節點切換成新節點（向下進入）。
- **處理結束標籤 `handle_endtag()`**：遇到 `</tag>` 時，結束該節點，將目前節點回到父節點（往上回推）。
- **處理文字內容 `handle_data()`**：將純文字節點加入到當前節點下的 children，並作為 text 節點儲存。
- **組成簡易 DOM 樹**：所有節點透過 parent/children 串接起來，根節點為 `#document`，整體結構模仿真實網頁的 HTML 樹狀表示法。

---

## Encode 的核心作用

- **Byte Histogram 特徵表示**：將 payload 裡的每個字元轉換成 ASCII 值，統計每個字元的出現頻率，形成長度 256 的頻率向量（出現越多次的字元在向量中數值越大）。
- **加上字串長度**：為了幫助模型感知 payload 的整體規模，除了頻率向量外，還在最前面加上一個「字串長度」作為額外特徵。
- **組成 257 維的狀態向量**：最終結果是 `[長度, freq[0], freq[1], ..., freq[255]]`，共 257 維，是模型的輸入資料格式。
- **統一處理非 ASCII 字元**：若字元的 ASCII 值超過 255，會歸類到最後一格 `freq[255]`，確保不會錯誤或超出索引。

---

## Sum Tree 的核心作用

- **提升學習效率，專注於重要經驗**：傳統的經驗回放機制是隨機取樣經驗，效率不高，因為並非所有經驗都同等重要。Sum Tree 讓 AI 能夠優先學習那些對它來說更重要、更能從中學到東西的經驗，例如 AI 預測誤差較大的樣本。這樣可以加速演算法的收斂速度，並提升探索能力。
- **高效地儲存和挑選經驗**：為了避免每次挑選經驗時都耗費大量計算資源去排序所有經驗的重要性，Sum Tree 採用一種特殊的樹狀結構。它能夠在不需要耗費大量時間排序的情況下，快速有效地找出高優先級的經驗。

---

## XSSEnv 的核心作用

- **模擬 WAF 過濾行為（simulate_filter()）**：模擬真實網站的過濾機制，例如移除 `<script>`、去除 `javascript:`、消除 `onerror=` 等攻擊語法。
- **套用變異動作（step()）**：接收 AI 選擇的某個變異策略（從 ActionTable.py），套用在目前的 payload 上，並產生新的 payload。
- **靜態分析檢查攻擊是否成功（_static_check_trigger()）**：用 MyHTMLParse.py 解析變異後的 payload，檢查是否還包含可疑函數（如 alert、prompt），若有可能觸發 XSS。
- **動態驗證（可選，_dynamic_verify()）**：可進一步接入 Selenium WebDriver 等工具，模擬瀏覽器實際點擊/顯示是否真的會彈窗，是更真實的驗證方式。
- **計算 reward（回饋分數）**：
  - 成功觸發彈窗 → 給予主獎勵 +10 分。
  - 沒成功 → 利用 Levenshtein 編輯距離計算變異後 payload 與過濾後結果的差異，給予類似度獎勵（越像越好）。
  - 動作結束條件：成功觸發，或達到最大步數。
- **更新狀態與輸出結果**：每次 step() 完會回傳新狀態向量、reward 值、是否結束、額外資訊（如是否觸發成功）。
